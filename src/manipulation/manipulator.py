#===============================================================================
# MANIPULATOR
# Processes text and requests manipulations to turn it into poetry.
#
# EXPORTS
# Manipulator, Manipulator.manipulate, Manipulator.get_poems
#===============================================================================

import options as o
from . import _poems, _rhyme, _meter
from language.word import Word
from language.poem import Poem
from language import _synonym
import itertools
from typing import Iterable

class Manipulator(object):
    """
    Stores the text base and variants of its words, and provides tools for
    manipulating them into poems.
    """
    
    # Initialize core attributes
    _base, _words, _poems, _variants = '', [], [], []
    
    MAX_VARIANTS = 20 # Keep this low or else memory usage goes up very fast
    AVG_WORDS = 40 # The number of words to generate MAX_VARIANTS variants

    def __init__(self, base: str) -> None:
        """Process the base and do each manipulation."""
        
        # Process the base string
        self._process_base(base)
        
        # Get synonymic variants
        self._process_variants()
    
    #===========================================================================
    # TEXT PROCESSING
    #===========================================================================        
    
    def _process_base(self, base: str):
        """Process the given string and save it as a base and words."""
        
        # Preliminary cleanup of the base string
        self._base = _strip(base)
        
        # If not stripping punctuation, isolate it so it can tokenize
        if not o.OPTIONS['STRIP_PUNCT']:
            o.LAST_WAS_PUNCT = self._base[-1] in o.OKAY_PUNCT
            self._base = _unfold_punctuation(self._base)
        
        # Tokenize into words
        self._words = (Word(w) for w in self._base.split(' ') if w.strip())
        
        # Provision for invalid Words that have self-destructed as Nones
        self._words = [w for w in self._words if w]
        
        # Eliminate stopwords if the user has requested ellipsis
        if o.OPTIONS['NO_STOP']:
            self._words = [w for w in self._words if w not in o.SW_ELLIPSIS]
        
        # Initialize variants with the original words
        self._variants = [self._words]
        
        
    def _process_variants(self):
        """Process the words into all the synonymic variants required."""
        
        if o.OPTIONS['S']:
            
            # The user wants only the best variants
            if o.OPTIONS['BEST_VARIANTS']:
                rarest = _synonym.get_rarest_variant(self._words)
                poeticest = _synonym.get_poeticest_variant(self._words)
                
                self._variants.extend([rarest, poeticest])
            
            # The user wants all the variants we can afford to generate
            else:                
                n = int(self.MAX_VARIANTS * (self.AVG_WORDS / len(self._words)))
        
                variant_gen = _synonym.get_all_variants(self._words)
                variant_slice = itertools.islice(variant_gen, n)
                
                self._variants.extend(variant_slice)
        
        # Strip any duplicates
        self._variants = set(tuple(variant) for variant in self._variants)
        
    #===========================================================================
    # POEM MAKING
    #===========================================================================
    
    def _get_base_poems(self) -> Iterable[Poem]:
        """Yield the rhyming poems generated by each variant of the words."""
        
        for variant in self._variants:
            yield _poems.get_poems(variant)
            
            
    def manipulate(self):
        """Perform all manipulations of this poem."""
        
        for poems in self._get_base_poems():
            self._poems.extend(poems)
        
        # Filter by rhyme requirements
        if o.OPTIONS['R']:
            self._poems = _rhyme.filter_poems(self._poems)
        
        # Filter by meter requirements
        if o.OPTIONS['M']:
            self._poems = _meter.filter_poems(self._poems)
        
        # Remove duplicate poems
        self._poems = set(poem for poem in self._poems if poem)
            
    #===========================================================================
    # POEM YIELDING
    #===========================================================================
    
    def get_poems(self) -> Iterable[tuple]:
        """Return a generator of (poem, score) tuples."""
        
        poems = self._poems        
        all_scores = (poem.score() for poem in poems)        
        return zip(poems, all_scores)
        
#===============================================================================
# MODULE-LEVEL FUNCTIONS
#===============================================================================

def _unfold_punctuation(s: str) -> str:
    """Put spacing around punctuation to make it tokenize separately."""
    
    new = ''
    for c in s:
        new += c if c not in o.OKAY_PUNCT else ' {} '.format(c)
    return new


def _strip(s: str) -> str:
    """Strip/clean and return the given string."""
    
    return ''.join([c for c in s 
                    if c.isalpha()
                    or c.isspace() 
                    or c.isdigit()
                    or c in "-'"
                    or (not o.OPTIONS['STRIP_PUNCT'] and c in o.OKAY_PUNCT)])
